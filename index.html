<!doctype HTML>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <!-- Update to newer versions of A-Frame and AR.js -->
  <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <!-- Add ARJS-device-orientation for better iOS compatibility -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex-location-only.js"></script>
  <!-- Add SLAM support with WebXR -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
  <script>
    // Modified hit-test component with SLAM support for better ground detection
    AFRAME.registerComponent('hit-test', {
      init: function () {
        const box = document.querySelector('#ar-box');
        box.setAttribute('visible', 'false');
        
        // Add a ground plane for better visualization
        const groundPlane = document.createElement('a-plane');
        groundPlane.setAttribute('id', 'ground-plane');
        groundPlane.setAttribute('rotation', '-90 0 0');
        groundPlane.setAttribute('width', '100');
        groundPlane.setAttribute('height', '100');
        groundPlane.setAttribute('color', '#7BC8A4');
        groundPlane.setAttribute('material', 'transparent: true; opacity: 0.2');
        groundPlane.setAttribute('visible', 'false');
        this.el.sceneEl.appendChild(groundPlane);
        
        // Check if WebXR is available and supported
        if (navigator.xr) {
          console.log('WebXR is available');
          this.setupWebXRSLAM();
        } else {
          console.log('WebXR not available - falling back to AR.js');
        }
        
        // Track if we've detected the ground
        this.groundDetected = false;
        this.groundY = -1.6; // Default ground height (adjust based on testing)
        
        // Detect device orientation for better ground placement
        window.addEventListener('deviceorientation', (event) => {
          if (!this.groundDetected && event.beta) {
            // Use device orientation to estimate ground plane
            // Beta is the front-to-back tilt in degrees
            const tiltAngle = event.beta;
            console.log('Device tilt:', tiltAngle);
            
            // If device is pointing downward, we can estimate the ground
            if (tiltAngle > 45 && tiltAngle < 135) {
              this.groundY = -1.0; // Adjust based on camera height
              this.groundDetected = true;
              groundPlane.setAttribute('position', `0 ${this.groundY} 0`);
              groundPlane.setAttribute('visible', 'true');
              console.log('Ground plane estimated at y =', this.groundY);
            }
          }
        });
        
        // Handle touch events for iOS
        document.addEventListener('touchstart', (event) => {
          // Prevent default behavior for touch events
          event.preventDefault();
          
          console.log('Touch event detected');
          
          // Get screen touch coordinates
          const touch = event.touches[0];
          const touchX = touch.clientX / window.innerWidth;
          const touchY = touch.clientY / window.innerHeight;
          
          console.log(`Touch coordinates: ${touchX}, ${touchY}`);
          
          // Try WebXR SLAM hit testing first if available
          if (this.xrHitTestSource && this.xrSession) {
            console.log('Using WebXR SLAM hit testing');
            return; // The hit test results will be handled in the XR frame callback
          }
          
          // Try AR.js hit testing next
          const arjsSystem = this.el.sceneEl.systems['arjs'];
          if (arjsSystem && arjsSystem.hitTesting) {
            const hitPosition = arjsSystem.hitTesting.getHitPosition();
            if (hitPosition) {
              console.log('AR.js hit position found:', hitPosition);
              box.setAttribute('position', hitPosition);
              box.setAttribute('visible', 'true');
              return;
            }
          }
          
          // Improved ground plane fallback
          console.log('Using ground plane fallback positioning');
          const camera = document.querySelector('[camera]');
          if (camera) {
            // Get camera position and rotation
            const cameraPosition = camera.getAttribute('position');
            const cameraRotation = camera.getAttribute('rotation');
            const radians = THREE.MathUtils.degToRad(cameraRotation.y);
            
            // Calculate ray from camera based on touch position
            const rayX = (touchX - 0.5) * 2; // -1 to 1 range
            const rayY = (0.5 - touchY) * 2; // -1 to 1 range
            
            // Calculate intersection with ground plane
            // Simple ray-plane intersection
            const groundY = this.groundY;
            
            // Direction vector from camera to touch point
            const dirX = Math.sin(radians) + rayX * 0.5;
            const dirY = -rayY * 0.5;
            const dirZ = -Math.cos(radians);
            
            // Normalize direction vector
            const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
            const normDirX = dirX / length;
            const normDirY = dirY / length;
            const normDirZ = dirZ / length;
            
            // Calculate t for intersection with ground plane
            if (Math.abs(normDirY) > 0.0001) {
              const t = (groundY - cameraPosition.y) / normDirY;
              
              if (t > 0) {
                // Calculate intersection point
                const intersectX = cameraPosition.x + normDirX * t;
                const intersectZ = cameraPosition.z + normDirZ * t;
                
                console.log(`Ground intersection at: ${intersectX}, ${groundY}, ${intersectZ}`);
                
                // Place box at intersection
                box.setAttribute('position', {x: intersectX, y: groundY, z: intersectZ});
                box.setAttribute('visible', 'true');
              }
            }
          }
        });
        
        // Keep original event listeners for non-iOS devices
        this.el.addEventListener('ar-hit-test-start', () => {
          console.log('AR hit testing started');
        });
        
        this.el.addEventListener('ar-hit-test-achieved', (event) => {
          console.log('AR hit test achieved');
          const position = event.detail.position;
          box.setAttribute('position', position);
          box.setAttribute('visible', 'true');
        });
      },
      
      // Add new method for WebXR SLAM setup
      setupWebXRSLAM: function() {
        if (!navigator.xr) return;
        
        // Check if immersive-ar is supported
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
          if (supported) {
            console.log('Immersive AR is supported - setting up SLAM');
            
            // Request a session when the user interacts with the page
            document.addEventListener('click', () => {
              if (!this.xrSession) {
                this.startXRSession();
              }
            }, { once: true });
          } else {
            console.log('Immersive AR not supported - falling back to AR.js');
          }
        });
      },
      
      startXRSession: function() {
        navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test', 'local-floor']
        }).then((session) => {
          this.xrSession = session;
          console.log('XR Session started');
          
          // Set up hit test source
          session.requestReferenceSpace('viewer').then((viewerSpace) => {
            session.requestHitTestSource({ space: viewerSpace }).then((hitTestSource) => {
              this.xrHitTestSource = hitTestSource;
              console.log('Hit test source created');
            });
          });
          
          // Get local floor reference space for better ground tracking
          session.requestReferenceSpace('local-floor').then((floorSpace) => {
            this.xrFloorSpace = floorSpace;
            console.log('Floor reference space acquired');
            
            // Update ground plane based on floor space
            const groundPlane = document.querySelector('#ground-plane');
            groundPlane.setAttribute('position', '0 0 0');
            groundPlane.setAttribute('visible', 'true');
            this.groundDetected = true;
          });
          
          // Set up frame loop
          session.addEventListener('end', () => {
            console.log('XR Session ended');
            this.xrSession = null;
            this.xrHitTestSource = null;
          });
          
          // Process each XR frame
          session.requestAnimationFrame((time, frame) => {
            this.onXRFrame(time, frame);
          });
        }).catch((error) => {
          console.error('Failed to start XR session:', error);
        });
      },
      
      onXRFrame: function(time, frame) {
        const session = this.xrSession;
        if (!session) return;
        
        // Continue the frame loop
        session.requestAnimationFrame((newTime, newFrame) => {
          this.onXRFrame(newTime, newFrame);
        });
        
        // Get hit test results if available
        if (this.xrHitTestSource && frame) {
          const hitTestResults = frame.getHitTestResults(this.xrHitTestSource);
          
          if (hitTestResults.length > 0) {
            const hitPose = hitTestResults[0].getPose(this.xrFloorSpace);
            if (hitPose) {
              const box = document.querySelector('#ar-box');
              const position = hitPose.transform.position;
              
              // Convert WebXR coordinates to A-Frame coordinates
              box.setAttribute('position', {
                x: position.x,
                y: position.y,
                z: position.z
              });
              box.setAttribute('visible', 'true');
              
              console.log('SLAM hit test positioned object at:', position);
            }
          }
        }
      }
    });
  </script>
  <!-- Add iOS-specific meta tags -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
</head>
<body style='margin: 0; overflow: hidden;'>
  <a-scene
    vr-mode-ui="enabled: false"
    embedded
    arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono; trackingMethod: best;"
    hit-test>
    
    <a-box id="ar-box" 
           rotation="0 45 0" 
           scale="0.5 0.5 0.5" 
           material="opacity: 0.8; color: #4CC3D9;"
           visible="false"></a-box>
    
    <a-entity camera></a-entity>
  </a-scene>
</body>
</html>
